game.module(    'game.objects.car').require(    'game.objects.tileData').body(function(){        Car = game.Class.extend({                init: function(options) {                        this.sprite = new game.Sprite(options.imageName, 0, 0,                                          {anchor: {x: 0.5, y: 0.4},                                           width: Car.WIDTH,                                           height: Car.HEIGHT});                        game.scene.map.container.addChild(this.sprite);                        game.scene.addObject(this);                        this.direction = this.lastDirection = 'up';        },                rotateToDirection: function(direction) {                        this.lastDirection = this.direction;                        var currentDirectionVector = TileData.DIRECTIONS_VECTORS[this.direction];            var newDirectionVector = TileData.DIRECTIONS_VECTORS[direction];                        var currentRotationAngle = Math.atan2(currentDirectionVector.x, currentDirectionVector.y * -1);            var newRotationAngle = Math.atan2(newDirectionVector.x, newDirectionVector.y * -1);                        var newAngle = this.sprite.rotation + (newRotationAngle - currentRotationAngle);                        var difference = ((((newAngle - this.sprite.rotation) % (2 * Math.PI)) + (3 * Math.PI)) % (2 * Math.PI)) - Math.PI;                        newAngle = (this.sprite.rotation + difference);                        var tween = new game.Tween(this.sprite)                .to({rotation: newAngle}, 100)                .start();                        this.direction = direction;        },                isCloseEnoughToTile: function(tileData) {                        return game.Math.distance(                    tileData.position.x, tileData.position.y,                    this.sprite.position.x, this.sprite.position.y) < (Map.TILE_HALF_WIDTH / 2.0);        },                chooseNextDirection: function(tileData) {                        if (tileData.allowedDirections.indexOf(this.direction) < 0) {                                var newDirection = null;                                if (tileData.allowedDirections.indexOf(this.lastDirection) >= 0) {                                        newDirection = this.lastDirection;                }                else {                    _.each(tileData.allowedDirections, function(tileDirection) {                        if (!newDirection) {                                                        var currentDirectionVector = TileData.DIRECTIONS_VECTORS[this.direction];                            var tileDirectionVector = TileData.DIRECTIONS_VECTORS[tileDirection];                                                        var dotProduct = currentDirectionVector.dot(tileDirectionVector);                                                        if (dotProduct != -1) {                                newDirection = tileDirection;                            }                        }                    }, this);                }                                this.rotateToDirection(newDirection);                                this.sprite.position = _.clone(tileData.position);            }        },                update: function() {                        var tileData = game.scene.map.tileForPosition(this.sprite.position);                        if (this.isCloseEnoughToTile(tileData)) {                                this.chooseNextDirection(tileData);            }                        var displacement = Car.VELOCITY * game.system.delta;                        var directionVector = TileData.DIRECTIONS_VECTORS[this.direction];                        this.sprite.position.x += (displacement * directionVector.x);            this.sprite.position.y += (displacement * directionVector.y);        }    });        _.extend(Car,        {           VELOCITY: 400,           WIDTH: 51,           HEIGHT: 84        });});